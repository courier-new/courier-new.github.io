import flow from 'lodash/flow';
import groupBy from 'lodash/groupBy';
import map from 'lodash/map';
import reduce from 'lodash/reduce';
import reverse from 'lodash/reverse';
import sortBy from 'lodash/sortBy';
import { DateTime, Interval } from 'luxon';

export const VIRTUAL = 'Virtual';
export const CANCELLED = 'Cancelled';
export const PASSED = 'Passed';
export const NOW = 'Happening Now';
export const NEXT = 'Next Up';

/** Type representing a conference's details */
export type Conference = {
  // TODO: Add location/url branded string types
  /** When the conference occurred, either as a single DateTime or an Interval */
  date: DateTime | Interval;
  /** A label about the time-based status of the conference, e.g. "Passed"; will
   * be automatically generated by addDateLabels() */
  dateLabel?: string;
  /** Any optional label about the conference, e.g. "Cancelled"; will overwrite
   * the date label in the display */
  label?: string;
  /** Where the conference occurred */
  location: string;
  /** The display name for the conference */
  name: string;
  /** The website URL for the conference */
  website: string;
};

/**
 * Returns whether or not the provided conference has passed based on the date
 * or end date, in the case of an Interval date
 *
 * @param conference the conference to check
 */
export const hasPassed = (conference: Conference): boolean => {
  if (Interval.isInterval(conference.date)) {
    return conference.date.end.startOf('day') < DateTime.local().startOf('day');
  }
  return conference.date.startOf('day') < DateTime.local().startOf('day');
};

/**
 * Returns whether or not the provided conference is currently happening based
 * on the date, or based on the start and end date, in the case of a multi-day
 * conference date Interval
 *
 * @param conference the conference to check
 */
export const isCurrentlyHappening = (conference: Conference): boolean => {
  if (Interval.isInterval(conference.date)) {
    return (
      conference.date.start.startOf('day') < DateTime.local() &&
      conference.date.end.endOf('day') > DateTime.local()
    );
  }
  return (
    conference.date.hasSame(DateTime.local(), 'day') &&
    conference.date.hasSame(DateTime.local(), 'month') &&
    conference.date.hasSame(DateTime.local(), 'year')
  );
};

/**
 * Orders a list of conferences by their dates from earliest to latest, taking a
 * conference start date in the case of multi-day conference Intervals
 *
 * @param conferences the list of conferences to sort
 * @param reverseDate whether to reverse sort conferences from latest to
 * earliest instead
 */
export const sortByDate = (
  conferences: Conference[],
  reverseDate = false,
): Conference[] => {
  const sorted = sortBy(conferences, (conference) => {
    if (Interval.isInterval(conference.date)) {
      return conference.date.start;
    }
    return conference.date;
  });
  if (reverseDate) return reverse(sorted);
  return sorted;
};

/**
 * Applies a label of "happening now" to any conferences that are currently
 * happening and "next up" to any conferences on or starting on the next closest
 * date
 *
 * @param conferences the list of conferences, sorted from earliest to latest
 */
export const addNextUpLabels = (conferences: Conference[]): Conference[] => {
  let nextUpDate: DateTime | null = null;
  return reduce(
    conferences,
    (acc: Conference[], conference: Conference) => {
      let dateLabel: string | undefined;

      if (isCurrentlyHappening(conference)) {
        dateLabel = NOW;
      } else if (nextUpDate) {
        const conferenceStartDate = Interval.isInterval(conference.date)
          ? conference.date.start
          : conference.date;
        if (nextUpDate.equals(conferenceStartDate)) {
          dateLabel = NEXT;
        }
      } else {
        dateLabel = NEXT;
        nextUpDate = Interval.isInterval(conference.date)
          ? conference.date.start
          : conference.date;
      }
      return [
        ...acc,
        {
          // Allow the current Conference dateLabel property to overwrite this
          dateLabel,
          ...conference,
        },
      ];
    },
    [],
  );
};

type ConferencesKeyedByYear = { [year: string]: Conference[] };
type ConferencesDiscriminatedArray = { conferences: Conference[]; year: string }[];

/**
 * Groups conferences by year and returns them in an array of objects
 * distinguishable by their `year` property sorted from latest year to earliest
 * year, e.g. [{ year: 2020, conferences: [] }, { year: 2019, conferences: [] },
 * ...]
 *
 * @param conferences the list of conferences to restructure and group
 */
export const groupByYears = (
  conferences: Conference[],
): ConferencesDiscriminatedArray => {
  return flow(
    // Group conferences by date as a key
    (c: Conference[]): ConferencesKeyedByYear =>
      groupBy(c, (conference) => {
        if (Interval.isInterval(conference.date)) {
          return conference.date.start.year;
        }
        return conference.date.year;
      }),
    // Restructure to array of objects with year key as an object property
    (c: ConferencesKeyedByYear): ConferencesDiscriminatedArray =>
      map(c, (conferencesForYear, year) => ({
        conferences: conferencesForYear,
        year,
      })),
    // Sort array by year from latest -> earliest
    (c: ConferencesDiscriminatedArray): ConferencesDiscriminatedArray =>
      sortBy(c, ({ year }) => -parseInt(year, 10)),
  )(conferences);
};
